// Generated by CoffeeScript 1.7.1
(function() {
  var Event;

  Event = (function() {
    function Event() {
      this.handlers = [];
    }

    Event.prototype.subscribe = function(func) {
      return this.handlers.push(func);
    };

    Event.prototype.trigger = function(event) {
      var handler, _i, _len, _ref, _results;
      _ref = this.handlers;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        handler = _ref[_i];
        _results.push(handler(event));
      }
      return _results;
    };

    return Event;

  })();

  this.Socket = (function() {
    function Socket(connect_string) {
      this.connect_string = connect_string;
      this.timeoutInterval = 2000;
      this.reconnectInterval = 1000;
      this.debug = true;
      this.clientClosedConnection = false;
      this.onMessage = new Event;
      this.onOpen = new Event;
      this.onClose = new Event;
      this.onReconnect = new Event;
      this.onError = new Event;
    }

    Socket.prototype.connect = function(reconnectAttempt) {
      var timeout;
      if (reconnectAttempt == null) {
        reconnectAttempt = false;
      }
      if (window.WebSocket) {
        this._ws = new WebSocket(this.connect_string);
      } else if (window.MozWebSocket) {
        this._ws = new MozWebSocket(this.connect_string);
      } else {
        console.log("WebSocket Not Supported");
      }
      timeout = setTimeout((function(_this) {
        return function() {
          _this.timedOut = true;
          _this._ws.close();
          return _this.timedOut = false;
        };
      })(this), this.timeoutInterval);
      this._ws.onopen = (function(_this) {
        return function(e) {
          if (_this.debug) {
            console.debug('Socket', 'onopen', _this.connect_string);
          }
          clearTimeout(timeout);
          if (reconnectAttempt) {
            _this.onReconnect.trigger(e);
            return _this.reconnectAttempt = false;
          } else {
            return _this.onOpen.trigger(e);
          }
        };
      })(this);
      this._ws.onclose = (function(_this) {
        return function(e) {
          if (_this.debug) {
            console.debug('Socket', 'onclose', _this.connect_string);
          }
          clearTimeout(timeout);
          _this._ws = null;
          if (_this.clientClosedConnection) {
            return _this.onClose.trigger(e);
          } else {
            if (!reconnectAttempt && !_this.timedOut) {
              console.debug("Socket", "onclose", _this.connect_string);
              _this.onClose.trigger(e);
            }
            return setTimeout(function() {
              return _this.connect(true);
            }, _this.reconnectInterval);
          }
        };
      })(this);
      this._ws.onmessage = (function(_this) {
        return function(e) {
          if (_this.debug) {
            console.debug('Socket', 'onmessage', _this.connect_string, event.data);
          }
          return _this.onMessage.trigger(e);
        };
      })(this);
      return this._ws.onerror = (function(_this) {
        return function(e) {
          if (_this.debug) {
            console.debug('Socket', 'onerror', _this.connect_string, event);
          }
          return _this.onError.trigger(e);
        };
      })(this);
    };

    Socket.prototype.send = function(data) {
      if (this.debug) {
        console.debug('Socket', 'send', this.connect_string, data);
      }
      return this._ws.send(data);
    };

    Socket.prototype.sendMessage = function(message) {
      console.debug('Socket', 'sendMessage', this.connect_string, message);
      return this._ws.send(JSON.stringify(message));
    };

    Socket.prototype.close = function() {
      if (this.debug) {
        console.debug('Socket', 'close', this.connect_string, message);
      }
      this.clientClosedConnection = true;
      if (this._ws) {
        return this._ws.close();
      }
    };

    return Socket;

  })();

}).call(this);
